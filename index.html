<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="" />
    <link
      rel="stylesheet"
      as="style"
      onload="this.rel='stylesheet'"
      href="https://fonts.googleapis.com/css2?display=swap&family=Noto+Sans:wght@400;500;700;900&family=Public+Sans:wght@400;500;700;900"
    />
    <title>Dictation</title>
    <link rel="icon" type="image/x-icon" href="data:image/x-icon;base64," />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>

    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.sh/@google/genai@^1.1.0"
      }
    }
    </script>

    <!-- Added onload attributes directly -->
    <script src="https://apis.google.com/js/api.js" async defer onload="gapiLoadedCallback()"></script>
    <script src="https://accounts.google.com/gsi/client" async defer onload="gisLoadedCallback()"></script>

    <!--
      The following lines were outside the </html> tag.
      index.css is moved above. index.tsx is commented out as its content is not provided.
      If you need index.tsx, ensure the file exists and uncomment the script tag below,
      placing it preferably at the end of the body or in the head with defer.
    -->
    <!-- <link rel="stylesheet" href="index.css"> -->
    <!-- <script src="index.tsx" type="module"></script> -->

</head>
  <body>
    <div
      class="relative flex size-full min-h-screen flex-col bg-slate-50 group/design-root overflow-x-hidden"
      style='font-family: "Public Sans", "Noto Sans", sans-serif;'
    >
      <div class="flex-grow">
        <div class="flex items-center bg-slate-50 p-4 pb-2 justify-center">
          <h2 class="text-[#0d141c] text-lg font-bold leading-tight tracking-[-0.015em] flex-1 text-center">Dictation</h2>
        </div>
        <div class="pb-3">
          <div class="flex border-b border-[#cedbe8] px-4 gap-2 sm:gap-4 justify-center">
            <a id="tab-diary" class="category-tab flex flex-col items-center justify-center border-b-[3px] text-center flex-1 sm:flex-none border-b-[#0c7ff2] text-[#0d141c] pb-[13px] pt-4 cursor-pointer" data-category="Diary">
              <p class="text-sm font-bold leading-normal tracking-[0.015em]">Diary</p>
            </a>
            <a id="tab-ideas" class="category-tab flex flex-col items-center justify-center border-b-[3px] text-center flex-1 sm:flex-none border-b-transparent text-[#49739c] pb-[13px] pt-4 cursor-pointer" data-category="Ideas">
              <p class="text-sm font-bold leading-normal tracking-[0.015em]">Ideas</p>
            </a>
            <a id="tab-notes" class="category-tab flex flex-col items-center justify-center border-b-[3px] text-center flex-1 sm:flex-none border-b-transparent text-[#49739c] pb-[13px] pt-4 cursor-pointer" data-category="Notes">
              <p class="text-sm font-bold leading-normal tracking-[0.015em]">Notes</p>
            </a>
            <a id="tab-all" class="category-tab flex flex-col items-center justify-center border-b-[3px] text-center flex-1 sm:flex-none border-b-transparent text-[#49739c] pb-[13px] pt-4 cursor-pointer" data-category="All">
              <p class="text-sm font-bold leading-normal tracking-[0.015em]">All Notes</p>
            </a>
          </div>
        </div>
        <div class="flex px-4 py-3 justify-center">
          <button
            id="dictationButton"
            class="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-12 px-5 bg-[#0c7ff2] text-slate-50 text-base font-bold leading-normal tracking-[0.015em] hover:bg-[#0a6ac7] transition-colors duration-150"
          >
            <span class="truncate" id="dictationButtonText">Start Dictation</span>
          </button>
        </div>
        <div id="statusMessage" class="text-slate-600 text-sm text-center py-1 px-4"></div>

        <h2 id="polishedDictationTitle" class="text-[#0d141c] text-[22px] font-bold leading-tight tracking-[-0.015em] px-4 pb-3 pt-5">Current Dictation</h2>
        <div class="mx-4 mb-3 p-4 bg-white rounded-md shadow">
            <p id="polishedDictationContent" class="text-[#0d141c] text-base font-normal leading-normal whitespace-pre-wrap min-h-[100px]">
            </p>
        </div>
        <div class="flex px-4 pb-3 justify-center">
            <button
              id="saveToDriveButton"
              disabled
              class="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-10 px-4 bg-green-600 text-slate-50 text-sm font-bold leading-normal tracking-[0.015em] hover:bg-green-700 transition-colors duration-150 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              <span class="truncate" id="saveToDriveButtonText">Save to Google Drive</span>
            </button>
          </div>

        <div class="px-4 pt-8 pb-4">
          <div class="flex justify-between items-center mb-3">
            <h2 class="text-[#0d141c] text-xl font-bold leading-tight tracking-[-0.015em]">Past Dictations</h2>
            <p id="totalWordCount" class="text-[#49739c] text-sm font-medium">Total words: 0</p>
          </div>
          <div id="pastNotesList" class="space-y-3">
            <!-- Past notes will be rendered here by JavaScript -->
            <p id="noNotesMessage" class="text-slate-500 text-center py-4">No dictations found for this category.</p>
          </div>
        </div>
      </div>
      <div class="h-5 bg-slate-50"></div>
    </div>

    <script type="module">
      import { GoogleGenerativeAI } from '@google/genai'; // Changed import

      // --- START OF API KEY CONFIGURATION ---
      // IMPORTANT: Replace the placeholder values below with your actual API keys.
      // For production, DO NOT embed API keys directly in client-side code.
      // Consider a backend proxy or serverless functions.
      // 1. Gemini API Key (for transcription and note polishing)
      const GEMINI_API_KEY = 'AIzaSyBV_7F65BuncR-VqdIr27SUgfRkDcRhNmY'; // <--- REPLACE THIS if it's still a placeholder!

      // 2. Google API Key (for Google Picker and Drive API features)
      //    Get this from Google Cloud Console.
      const GOOGLE_API_KEY = 'AIzaSyBiF93RRqjCRTqm3aaPyLXmt4kx2cRh8jM'; // <--- REPLACE THIS if it's still a placeholder!

      // 3. Google OAuth 2.0 Client ID (for Google Drive authentication)
      //    Get this from Google Cloud Console (Web application type).
      //    Ensure your JavaScript origins (e.g., http://localhost:PORT or your deployed app URL like https://yourusername.github.io) are authorized.
      const GOOGLE_CLIENT_ID = '1078561331282-q5j9ic06hff6l3rc26sdp5j0ea5qm36g.apps.googleusercontent.com'; // <--- REPLACE THIS if it's still a placeholder!
      // --- END OF API KEY CONFIGURATION ---

      const DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
      const MODEL_NAME = 'gemini-1.5-flash-latest'; // Changed to a generally available and capable model
      const LOCAL_STORAGE_KEY = 'dictationAppNotes';
      const INITIAL_TITLE = "Current Dictation";

      let genAI; // Will be instance of GoogleGenerativeAI

      // DOM Elements
      let dictationButton;
      let dictationButtonText;
      let polishedDictationTitleElement;
      let polishedDictationContentElement;
      let statusMessageElement;
      let categoryTabs;
      let pastNotesListElement;
      let noNotesMessageElement;
      let totalWordCountElement;
      let saveToDriveButton;
      let saveToDriveButtonText;

      // App State
      let mediaRecorder = null;
      let audioChunks = [];
      let isRecording = false;
      let currentStream = null;
      let currentPolishedText = null;
      let currentPolishedTitle = INITIAL_TITLE;

      let savedNotes = [];
      let currentCategory = 'Diary';

      const PLACEHOLDER_TEXT = "Your polished dictation will appear here. It will be saved automatically to local storage.";
      const START_BUTTON_TEXT = "Start Dictation";
      const STOP_BUTTON_TEXT = "Stop Dictation";
      const PROCESSING_BUTTON_TEXT = "Processing...";

      // Google API State
      let gapiLoaded = false;
      let gisLoaded = false;
      let pickerApiLoaded = false;
      let googleTokenClient = null;
      let googleAccessToken = null;

      // Utility Functions
      function countWords(text) {
        if (!text || text.trim() === '') return 0;
        return text.trim().split(/\s+/).length;
      }

      function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substring(2);
      }

      function localGenerateTitle(text) {
          const words = text.trim().split(/\s+/);
          if (words.length === 0) return "Untitled Note";
          if (words.length <= 5) return words.join(" ");
          return words.slice(0, 5).join(" ") + "...";
      }

      // UI Update Functions
      function updateStatus(message, isError = false) {
        if (statusMessageElement) {
          statusMessageElement.textContent = message;
          statusMessageElement.className = `text-sm text-center py-1 px-4 ${
            isError ? 'text-red-600 font-semibold' : 'text-slate-600'
          }`;
        }
      }

      function updateButtonState(text, disabled) {
        if (dictationButtonText) {
          dictationButtonText.textContent = text;
        }
        if (dictationButton) {
          dictationButton.disabled = disabled;
          if (disabled) {
            dictationButton.classList.add('opacity-70', 'cursor-not-allowed');
            dictationButton.classList.remove('hover:bg-[#0a6ac7]');
          } else {
            dictationButton.classList.remove('opacity-70', 'cursor-not-allowed');
            dictationButton.classList.add('hover:bg-[#0a6ac7]');
          }
        }
      }

      function updateSaveToDriveButton(text, disabled) {
          if (saveToDriveButtonText) saveToDriveButtonText.textContent = text;
          if (saveToDriveButton) saveToDriveButton.disabled = disabled;
      }

      function displayCurrentPolishedNote(text, title) {
        currentPolishedText = text;
        currentPolishedTitle = title || INITIAL_TITLE;

        if (polishedDictationContentElement) {
          polishedDictationContentElement.textContent = text;
        }
        if (polishedDictationTitleElement) {
          polishedDictationTitleElement.textContent = currentPolishedTitle;
        }

        const canSave = currentPolishedText && currentPolishedText.trim() !== '' && currentPolishedText !== PLACEHOLDER_TEXT;
        if (pickerApiLoaded && googleTokenClient && googleAccessToken) { // Check token as well for more accurate readiness
          updateSaveToDriveButton('Save to Google Drive', !canSave);
        } else if (pickerApiLoaded && googleTokenClient) {
           updateSaveToDriveButton('Authenticate & Save', !canSave);
        } else {
           updateSaveToDriveButton('Loading Drive...', true);
        }
      }

      function resetToReadyState(statusText) {
          updateButtonState(START_BUTTON_TEXT, false);
          updateStatus(statusText || "Ready to dictate.");
          isRecording = false;
          if (currentStream) {
              currentStream.getTracks().forEach(track => track.stop());
              currentStream = null;
          }
          mediaRecorder = null;
          audioChunks = [];

          // Re-evaluate save button state based on currentPolishedText and Drive readiness
          const canSave = currentPolishedText && currentPolishedText.trim() !== '' && currentPolishedText !== PLACEHOLDER_TEXT;
          if (pickerApiLoaded && googleTokenClient && googleAccessToken) {
              updateSaveToDriveButton('Save to Google Drive', !canSave);
          } else if (pickerApiLoaded && googleTokenClient) {
              updateSaveToDriveButton('Authenticate & Save', !canSave);
          } else {
              updateSaveToDriveButton('Loading Drive...', true);
          }
      }

      function setActiveTab() {
        categoryTabs.forEach(tab => {
          if (tab.dataset.category === currentCategory) {
            tab.classList.remove('border-b-transparent', 'text-[#49739c]');
            tab.classList.add('border-b-[#0c7ff2]', 'text-[#0d141c]');
          } else {
            tab.classList.remove('border-b-[#0c7ff2]', 'text-[#0d141c]');
            tab.classList.add('border-b-transparent', 'text-[#49739c]');
          }
        });
      }

      function renderPastNotes() {
        if (!pastNotesListElement || !noNotesMessageElement || !totalWordCountElement) return;
        pastNotesListElement.innerHTML = '';
        const notesToDisplay = currentCategory === 'All'
          ? savedNotes
          : savedNotes.filter(note => note.category === currentCategory);
        notesToDisplay.sort((a, b) => b.timestamp - a.timestamp);
        let currentTotalWords = 0;
        if (notesToDisplay.length === 0) {
          noNotesMessageElement.style.display = 'block';
        } else {
          noNotesMessageElement.style.display = 'none';
          notesToDisplay.forEach(note => {
            const noteElement = document.createElement('div');
            noteElement.className = 'p-4 bg-white rounded-lg shadow hover:shadow-md transition-shadow cursor-pointer';
            noteElement.setAttribute('aria-label', `Note: ${note.title}`);
            const titleEl = document.createElement('h3');
            titleEl.className = 'text-md font-semibold text-[#0d141c] mb-1 truncate';
            titleEl.textContent = note.title;
            const categoryEl = document.createElement('p');
            categoryEl.className = 'text-xs text-slate-500 mb-1';
            categoryEl.textContent = `Category: ${note.category}`;
            const contentPreviewEl = document.createElement('p');
            contentPreviewEl.className = 'text-sm text-slate-700 mb-2 line-clamp-3';
            contentPreviewEl.textContent = note.content;
            const dateEl = document.createElement('p');
            dateEl.className = 'text-xs text-slate-400 mb-1';
            dateEl.textContent = new Date(note.timestamp).toLocaleString();
            const wordCountEl = document.createElement('p');
            wordCountEl.className = 'text-xs text-[#0c7ff2] font-medium';
            wordCountEl.textContent = `Words: ${note.wordCount}`;
            noteElement.append(titleEl, categoryEl, contentPreviewEl, dateEl, wordCountEl);
            pastNotesListElement.appendChild(noteElement);
            currentTotalWords += note.wordCount;
          });
        }
        totalWordCountElement.textContent = `Total words: ${currentTotalWords}`;
      }

      function loadNotesFromStorage() {
        const notesJson = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (notesJson) {
          try {
            savedNotes = JSON.parse(notesJson);
          } catch (e) {
            console.error("Error parsing saved notes from localStorage:", e);
            savedNotes = [];
          }
        }
        renderPastNotes();
      }

      function saveNotesToStorage() {
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(savedNotes));
        } catch (e) {
          console.error("Error saving notes to localStorage:", e);
          updateStatus("Error saving note to local storage. Storage might be full.", true);
        }
      }

      async function generateTitleWithGemini(content) {
        if (!genAI) {
            updateStatus('Gemini AI not initialized. Using fallback title.', true);
            return localGenerateTitle(content);
        }
        if (!content || content.trim() === '') {
          return "Untitled Note";
        }
        updateStatus('Generating title...');
        try {
          const model = genAI.getGenerativeModel({ model: MODEL_NAME });
          const prompt = `Based on the following text, generate a concise and descriptive title, ideally between 3 to 7 words. The title should capture the main topic or essence of the text. Text:\n\n${content}`;
          const result = await model.generateContent(prompt);
          const response = result.response;
          const generatedTitle = response.text();

          if (generatedTitle && generatedTitle.trim() !== '') {
            currentPolishedTitle = generatedTitle.trim();
            return currentPolishedTitle;
          } else {
            updateStatus('Title generation returned empty, using fallback.', true);
            currentPolishedTitle = localGenerateTitle(content);
            return currentPolishedTitle;
          }
        } catch (error) {
          console.error('Error generating title with Gemini:', error);
          const errorMessage = error instanceof Error ? error.message : String(error);
          updateStatus(`Title generation error: ${errorMessage}. Using fallback.`, true);
          currentPolishedTitle = localGenerateTitle(content);
          return currentPolishedTitle;
        }
      }

      async function saveCurrentPolishedNoteToLocal() {
          if (!currentPolishedText || currentPolishedText.trim() === '' || currentPolishedText === PLACEHOLDER_TEXT) {
              updateStatus("No actual content to save locally.", true);
              return;
          }
          if (!currentPolishedTitle || currentPolishedTitle === INITIAL_TITLE || currentPolishedTitle === "New Dictation") {
              currentPolishedTitle = await generateTitleWithGemini(currentPolishedText);
          }
          updateStatus('Saving note locally...');
          const newNote = {
              id: generateId(),
              title: currentPolishedTitle,
              content: currentPolishedText,
              category: currentCategory,
              timestamp: Date.now(),
              wordCount: countWords(currentPolishedText),
          };
          savedNotes.push(newNote);
          saveNotesToStorage();
          renderPastNotes();
          updateStatus(`Note "${currentPolishedTitle}" saved to "${currentCategory}" locally!`);
          displayCurrentPolishedNote(currentPolishedText, currentPolishedTitle); // Refresh display
      }

      async function getTranscription(base64Audio, mimeType) {
        if (!genAI) {
            updateStatus('Gemini AI not initialized. Cannot transcribe.', true);
            resetToReadyState('Transcription service unavailable.');
            return;
        }
        updateStatus('Transcribing audio...');
        try {
          const model = genAI.getGenerativeModel({ model: MODEL_NAME });
          const audioPart = { inlineData: { data: base64Audio, mimeType: mimeType } };
          const textPromptPart = 'Generate a complete, detailed transcript of this audio, ensuring accuracy and capturing all spoken words.';

          const result = await model.generateContent([textPromptPart, audioPart]);
          const geminiResponse = result.response;
          const transcriptionText = geminiResponse.text();

          if (transcriptionText && transcriptionText.trim() !== '') {
            await getPolishedNote(transcriptionText);
          } else {
            updateStatus('Transcription failed or returned empty. Please try again.', true);
            displayCurrentPolishedNote('Could not transcribe audio. Please try again.', 'Transcription Failed');
            resetToReadyState('Transcription failed.');
          }
        } catch (error) {
          console.error('Error getting transcription:', error);
          const errorMessage = error.message || String(error);
          updateStatus(`Transcription error: ${errorMessage}. Please try again.`, true);
          displayCurrentPolishedNote(`Error during transcription: ${errorMessage}`, 'Transcription Error');
          resetToReadyState('Transcription error.');
        }
      }

      async function getPolishedNote(rawTranscription) {
        if (!genAI) {
            updateStatus('Gemini AI not initialized. Displaying raw transcription.', true);
            displayCurrentPolishedNote(`Gemini not ready. Raw content:\n${rawTranscription}`, "Raw Transcription");
            resetToReadyState('Polishing service unavailable.');
            return;
        }
        updateStatus('Polishing note...');
        try {
          const model = genAI.getGenerativeModel({ model: MODEL_NAME });
          const prompt = `Take this raw transcription and create a polished, well-formatted note.
                          Remove filler words (um, uh, like), repetitions, and false starts.
                          Organize the content logically. If there are lists or distinct points, format them clearly using markdown if appropriate (e.g., bullet points).
                          Ensure the core meaning and all significant information from the raw transcription are preserved.
                          The output should be suitable for direct reading as a coherent note.

                          Raw transcription:
                          ${rawTranscription}`;
          const result = await model.generateContent(prompt);
          const geminiResponse = result.response;
          const polishedText = geminiResponse.text();

          if (polishedText) {
            currentPolishedTitle = await generateTitleWithGemini(polishedText); // Generate title based on polished text
            displayCurrentPolishedNote(polishedText, currentPolishedTitle);
            await saveCurrentPolishedNoteToLocal(); // Auto-save after polishing
          } else {
            updateStatus('Polishing failed or returned empty. Displaying raw transcription.', true);
            currentPolishedTitle = await generateTitleWithGemini(rawTranscription); // Try title on raw
            displayCurrentPolishedNote(`Polishing failed. Raw content:\n${rawTranscription}`, currentPolishedTitle);
          }
        } catch (error) {
          console.error('Error polishing note:', error);
          const errorMessage = error.message || String(error);
          updateStatus(`Error polishing note: ${errorMessage}. Displaying raw transcription.`, true);
          currentPolishedTitle = await generateTitleWithGemini(rawTranscription); // Try title on raw
          displayCurrentPolishedNote(`Error during polishing. Raw content:\n${rawTranscription}\n\nError: ${errorMessage}`, currentPolishedTitle);
        } finally {
          // Status update is handled by saveCurrentPolishedNoteToLocal or error blocks
          // Ensure resetToReadyState reflects final status.
           const currentStatus = statusMessageElement.textContent;
           if (currentStatus && (currentStatus.includes("saved to") || currentStatus.includes("error") || currentStatus.includes("failed"))) {
                resetToReadyState(currentStatus);
           } else {
                resetToReadyState('Processing complete. Ready for new dictation.');
           }
        }
      }

      function handleMediaRecorderStop() {
          if (audioChunks.length === 0) {
              updateStatus('No audio data captured. Please try again.', true);
              resetToReadyState('No audio captured.');
              return;
          }
          updateButtonState(PROCESSING_BUTTON_TEXT, true);
          updateStatus('Processing audio...');
          updateSaveToDriveButton('Processing...', true); // Disable save while processing
          const mimeType = mediaRecorder?.mimeType || 'audio/webm'; // Default if somehow undefined
          const audioBlob = new Blob(audioChunks, { type: mimeType });
          audioChunks = []; // Clear for next recording

          const reader = new FileReader();
          reader.onloadend = async () => {
              try {
                  const base64data = reader.result;
                  if (typeof base64data !== 'string') {
                      throw new Error('FileReader did not return a string.');
                  }
                  const base64Audio = base64data.split(',')[1];
                  if (!base64Audio) throw new Error('Failed to convert audio to base64');
                  await getTranscription(base64Audio, mimeType);
              } catch (err) {
                  console.error('Error processing audio blob:', err);
                  const errorMessage = err instanceof Error ? err.message : String(err);
                  updateStatus(`Error processing audio: ${errorMessage}`, true);
                  displayCurrentPolishedNote(`Error processing audio: ${errorMessage}`, 'Audio Processing Error');
                  resetToReadyState('Audio processing error.');
              }
          };
          reader.onerror = () => {
              console.error('FileReader error:', reader.error);
              updateStatus(`FileReader error: ${reader.error?.message || 'Unknown error'}`, true);
              displayCurrentPolishedNote(`Error reading audio data: ${reader.error?.message || 'Unknown error'}`, 'Audio Read Error');
              resetToReadyState('Audio reading error.');
          };
          reader.readAsDataURL(audioBlob);
      }

      async function startRecording() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          updateStatus('getUserMedia not supported on your browser!', true);
          return;
        }
        updateButtonState(STOP_BUTTON_TEXT, false);
        updateStatus('Requesting microphone access...');
        updateSaveToDriveButton('Save to Google Drive', true); // Disable save during recording/new dictation
        displayCurrentPolishedNote('', 'New Dictation'); // Clear previous polished note
        currentPolishedText = ""; // Explicitly clear state
        currentPolishedTitle = "New Dictation";

        try {
          currentStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          updateStatus('Microphone access granted. Recording...');
          isRecording = true;
          audioChunks = []; // Ensure chunks are empty before starting
          const options = { mimeType: 'audio/webm' }; // Common, good quality
          // Fallback if webm is not supported, though highly unlikely in modern browsers
          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
              console.warn(`${options.mimeType} is not supported. Trying default.`);
              mediaRecorder = new MediaRecorder(currentStream); // browser default
          } else {
              mediaRecorder = new MediaRecorder(currentStream, options);
          }

          mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunks.push(event.data);
            }
          };
          mediaRecorder.onstop = handleMediaRecorderStop;
          mediaRecorder.onerror = (event) => {
              console.error('MediaRecorder error:', event);
              // ErrorEvent might not have .error property directly in all browsers or scenarios
              const errorName = event.error?.name || event.constructor?.name || 'Unknown MediaRecorderError';
              updateStatus(`Recording error: ${errorName}`, true);
              resetToReadyState('Recording error.');
          };
          mediaRecorder.start();
        } catch (err) {
          console.error('Error starting recording:', err);
          let message = `Error starting recording: ${err.message}.`;
          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            message = 'Microphone permission denied. Please allow access in your browser settings.';
          } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
            message = 'No microphone found. Please connect a microphone.';
          } else if (err.name === 'NotReadableError') {
             message = 'Microphone is already in use or not readable. Check other apps/tabs.';
          }
          updateStatus(message, true);
          resetToReadyState('Could not start recording.');
        }
      }

      async function stopRecording() {
        if (mediaRecorder && isRecording) {
          mediaRecorder.stop(); // This will trigger onstop and subsequently handleMediaRecorderStop
          // Tracks are stopped in resetToReadyState or handleMediaRecorderStop
          isRecording = false; // Set immediately
          updateStatus('Stopping recording, processing audio...');
          // Don't call resetToReadyState here, let handleMediaRecorderStop do its job
          if (currentStream) { // Stop tracks sooner
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
          }
        }
      }

      async function toggleRecording() {
        if (!dictationButton || dictationButton.disabled) return; // Check if button itself is disabled

        if (isRecording) {
          await stopRecording();
        } else {
          // Ensure Gemini is ready before allowing start
          if (!genAI) {
             updateStatus("CRITICAL: Gemini API not initialized. Cannot start dictation.", true);
             initApp(); // Attempt re-init
             if(!genAI) return; // if still not initialized after re-attempt
          }
          await startRecording();
        }
      }

      function handleCategoryTabClick(event) {
          const clickedTab = event.currentTarget;
          const category = clickedTab.dataset.category;
          if (category && category !== currentCategory) {
              currentCategory = category;
              setActiveTab();
              renderPastNotes();
              updateStatus(`Viewing ${category} notes.`);
          }
      }

      // Google API Integration
      // These functions are called by onload attributes of Google API script tags
      // and must be in the global scope.
      window.gapiLoadedCallback = function() {
          gapi.load('client:picker', initializePickerApi);
          gapiLoaded = true;
      }

      window.gisLoadedCallback = function() {
          if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID === 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com') {
              console.error('Google Client ID not configured (gisLoadedCallback).');
          }
          try {
            googleTokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: DRIVE_SCOPES,
                callback: handleGoogleTokenResponse,
            });
            gisLoaded = true;
          } catch (e) {
            console.error("Error initializing Google Identity Services Token Client:", e);
            updateStatus("Failed to initialize Google Sign-In. Drive features disabled.", true);
          }
          checkDriveApiReady();
      }

      function initializePickerApi() {
          if (!GOOGLE_API_KEY || GOOGLE_API_KEY === 'YOUR_GOOGLE_API_KEY_HERE') {
              console.error('Google API Key not configured (initializePickerApi).');
          }
          pickerApiLoaded = true;
          checkDriveApiReady();
      }

      function checkDriveApiReady() {
          const geminiKeyOk = GEMINI_API_KEY && GEMINI_API_KEY !== 'YOUR_GEMINI_API_KEY_HERE'; // Placeholder check
          const googleApiKeyOk = GOOGLE_API_KEY && GOOGLE_API_KEY !== 'YOUR_GOOGLE_API_KEY_HERE';
          const googleClientIdOk = GOOGLE_CLIENT_ID && GOOGLE_CLIENT_ID !== 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com';

          if (!geminiKeyOk) {
             // Already handled by initApp alert. Drive readiness is secondary.
             updateSaveToDriveButton('Drive: App Error', true);
             return;
          }

          const canSave = currentPolishedText && currentPolishedText.trim() !== '' && currentPolishedText !== PLACEHOLDER_TEXT;

          if (googleApiKeyOk && googleClientIdOk) {
              if (gapiLoaded && gisLoaded && pickerApiLoaded && googleTokenClient) {
                  if (googleAccessToken) {
                    updateStatus("Google Drive integration ready & authenticated.");
                    updateSaveToDriveButton('Save to Google Drive', !canSave);
                  } else {
                    updateStatus("Google Drive ready. Click 'Save' to authenticate.");
                    updateSaveToDriveButton('Authenticate & Save', !canSave);
                  }
              } else {
                  updateStatus("Loading Google Drive components...", false);
                  updateSaveToDriveButton('Loading Drive...', true);
              }
          } else {
              let missing = [];
              if (!googleApiKeyOk) missing.push("Google API Key");
              if (!googleClientIdOk) missing.push("Google Client ID");
              updateStatus(`Configure ${missing.join(' & ')} for Google Drive.`, true);
              updateSaveToDriveButton('Drive: Needs Config', true);
          }
      }


      async function handleSaveToDriveClick() {
          if (!currentPolishedText || currentPolishedText.trim() === '' || currentPolishedText === PLACEHOLDER_TEXT) {
              updateStatus("No content to save to Drive.", true);
              return;
          }
          if (!pickerApiLoaded || !googleTokenClient) {
              updateStatus("Google Drive integration is not ready. Check API Key/Client ID or wait for loading.", true);
              checkDriveApiReady(); // Re-check and update status
              return;
          }

          updateSaveToDriveButton('Authenticating...', true);
          updateStatus('Authenticating with Google...');

          // Check if token exists and is not expired (add a buffer, e.g., 60 seconds)
          if (googleAccessToken && googleAccessToken.expires_in && Date.now() < (googleAccessToken.issued_at + (googleAccessToken.expires_in - 60) * 1000) ) {
              createPicker();
          } else {
              googleTokenClient.requestAccessToken({ prompt: googleAccessToken ? '' : 'consent' }); // prompt 'consent' if no token yet
          }
      }

      function handleGoogleTokenResponse(response) {
          if (response.error) {
              console.error('Google OAuth Error:', response.error, response.error_description || response.details);
              updateStatus(`Google Auth Error: ${response.error_description || response.error || response.details || 'Unknown error'}.`, true);
              // Re-enable button only if there's content, otherwise it should stay disabled.
              const canSave = currentPolishedText && currentPolishedText.trim() !== '' && currentPolishedText !== PLACEHOLDER_TEXT;
              updateSaveToDriveButton('Authenticate & Save', !canSave);
              googleAccessToken = null;
              return;
          }
          googleAccessToken = {...response, issued_at: Date.now()}; // Store issuance time
          updateStatus('Authenticated with Google. Opening Drive Picker...');
          createPicker();
      }

      function createPicker() {
          if (!googleAccessToken || !pickerApiLoaded) {
              updateStatus("Cannot open Drive Picker: Not authenticated or Picker API not loaded.", true);
              const canSave = currentPolishedText && currentPolishedText.trim() !== '' && currentPolishedText !== PLACEHOLDER_TEXT;
              updateSaveToDriveButton(googleAccessToken ? 'Save to Google Drive' : 'Authenticate & Save', !canSave);
              return;
          }
          updateStatus('Opening Google Drive Picker...');

          const view = new google.picker.View(google.picker.ViewId.FOLDERS)
            .setMimeTypes("application/vnd.google-apps.folder");

          const picker = new google.picker.PickerBuilder()
              .enableFeature(google.picker.Feature.NAV_HIDDEN)
              .setAppId(GOOGLE_CLIENT_ID.split('.')[0]) // AppId is usually the numeric part of client ID
              .setOAuthToken(googleAccessToken.access_token)
              .addView(view)
              .setDeveloperKey(GOOGLE_API_KEY)
              .setCallback(pickerCallback)
              .setTitle('Select Folder to Save Note')
              .build();
          picker.setVisible(true);
          updateSaveToDriveButton('Picker Open...', true);
      }

      async function pickerCallback(data) {
          const canSaveCurrentContent = currentPolishedText && currentPolishedText.trim() !== '' && currentPolishedText !== PLACEHOLDER_TEXT;
          if (data[google.picker.Response.ACTION] == google.picker.Action.PICKED) {
              const doc = data[google.picker.Response.DOCUMENTS][0];
              const folderId = doc[google.picker.Document.ID];
              const defaultTitle = localGenerateTitle(currentPolishedText || "Untitled Dictation");
              const fileName = (currentPolishedTitle && currentPolishedTitle !== INITIAL_TITLE && currentPolishedTitle !== "New Dictation" ? currentPolishedTitle : defaultTitle) + ".txt";

              updateStatus(`Selected folder. Saving "${fileName}" to Google Drive...`);
              updateSaveToDriveButton('Saving to Drive...', true);
              await uploadFileToDrive(folderId, fileName, currentPolishedText || "");
          } else if (data[google.picker.Response.ACTION] == google.picker.Action.CANCEL) {
              updateStatus("Google Drive save cancelled.");
              updateSaveToDriveButton(googleAccessToken ? 'Save to Google Drive' : 'Authenticate & Save', !canSaveCurrentContent);
          } else {
              // Handles cases like closing the picker by pressing Esc or clicking outside
              updateStatus("Google Drive Picker closed.");
              updateSaveToDriveButton(googleAccessToken ? 'Save to Google Drive' : 'Authenticate & Save', !canSaveCurrentContent);
          }
      }

      async function uploadFileToDrive(folderId, fileName, fileContent) {
          try {
              await gapi.client.load('drive', 'v3');

              const metadata = {
                  name: fileName,
                  mimeType: 'text/plain',
                  parents: [folderId]
              };
              // Using gapi.client.drive.files.create for simplicity with text content
              const response = await gapi.client.drive.files.create({
                  resource: metadata,
                  media: {
                      mimeType: 'text/plain',
                      body: fileContent
                  },
                  fields: 'id,name'
              });

              updateStatus(`"${response.result.name}" successfully saved to Google Drive!`, false);
          } catch (error) {
              console.error('Error uploading file to Drive:', error);
              const errMessage = error.result?.error?.message || error.message || 'Unknown error during Drive upload';
              updateStatus(`Error saving to Drive: ${errMessage}`, true);
          } finally {
              const canSave = currentPolishedText && currentPolishedText.trim() !== '' && currentPolishedText !== PLACEHOLDER_TEXT;
              updateSaveToDriveButton(googleAccessToken ? 'Save to Google Drive' : 'Authenticate & Save', !canSave);
          }
      }


      function initApp() {
        let criticalConfigError = false;
        if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY_HERE') { // Check specific placeholder
            alert("CRITICAL ERROR: Gemini API Key is not configured!\n\nPlease edit the script and replace 'YOUR_GEMINI_API_KEY_HERE' (or the placeholder you see) with your actual Gemini API Key. Transcription and note polishing will NOT work.");
            criticalConfigError = true;
        }
        if (!GOOGLE_API_KEY || GOOGLE_API_KEY === 'YOUR_GOOGLE_API_KEY_HERE') {
             alert("CONFIGURATION NOTICE: Google API Key (for Drive Picker) is not configured.\n\nPlease edit the script and replace its placeholder with your actual Google API Key if you want to use Google Drive features.");
        }
        if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID === 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com') {
             alert("CONFIGURATION NOTICE: Google Client ID (for Drive Auth) is not configured.\n\nPlease edit the script and replace its placeholder with your actual Google OAuth 2.0 Client ID if you want to use Google Drive features.");
        }

        dictationButton = document.getElementById('dictationButton');
        dictationButtonText = document.getElementById('dictationButtonText');
        polishedDictationTitleElement = document.getElementById('polishedDictationTitle');
        polishedDictationContentElement = document.getElementById('polishedDictationContent');
        statusMessageElement = document.getElementById('statusMessage');
        categoryTabs = document.querySelectorAll('.category-tab');
        pastNotesListElement = document.getElementById('pastNotesList');
        noNotesMessageElement = document.getElementById('noNotesMessage');
        totalWordCountElement = document.getElementById('totalWordCount');
        saveToDriveButton = document.getElementById('saveToDriveButton');
        saveToDriveButtonText = document.getElementById('saveToDriveButtonText');

        // Callbacks for Google API scripts are now set directly on script tags' onload attribute.
        // No need to dynamically set them here.

        if (criticalConfigError) {
          updateStatus('CRITICAL: Gemini API Key not configured. App will not function correctly.', true);
          if (dictationButton) dictationButton.disabled = true;
          console.error('CRITICAL: Gemini API Key not configured.');
          displayCurrentPolishedNote('Application is not configured correctly. MISSING GEMINI API KEY.', 'Configuration Error');
        } else {
          try {
            genAI = new GoogleGenerativeAI(GEMINI_API_KEY); // Corrected constructor
            updateStatus("Gemini API Key loaded.", false);
          } catch (e) {
            console.error("Error initializing GoogleGenerativeAI:", e);
            updateStatus('CRITICAL: Error initializing Gemini API. Check API Key and network.', true);
            criticalConfigError = true;
            if (dictationButton) dictationButton.disabled = true;
            displayCurrentPolishedNote('Application could not initialize Gemini API.', 'Initialization Error');
          }
        }

        if (dictationButton && !criticalConfigError) {
          dictationButton.addEventListener('click', toggleRecording);
        }
        if (saveToDriveButton) {
          saveToDriveButton.addEventListener('click', handleSaveToDriveClick);
        }

        categoryTabs.forEach(tab => tab.addEventListener('click', handleCategoryTabClick));

        loadNotesFromStorage();
        setActiveTab();
        displayCurrentPolishedNote(PLACEHOLDER_TEXT, INITIAL_TITLE);
        resetToReadyState(criticalConfigError ? 'App disabled due to missing Gemini Key.' : 'Ready to dictate.');
        checkDriveApiReady(); // Initial check for Drive UI elements
      }
      document.addEventListener('DOMContentLoaded', initApp);
    </script>
  </body>
</html>
